export interface ParsedTransaction {
  id: string;
  hash: string; // Will be generated by backend
  date: string;
  valueDate?: string;
  partner: string;
  iban?: string;
  type: string;
  description: string;
  account: string;
  amount: number;
  originalAmount?: number;
  originalCurrency?: string;
  exchangeRate?: number;
  selected: boolean;
  isDuplicate: boolean;
  duplicateReason?: string;
}

export interface ParseResult {
  transactions: ParsedTransaction[];
  errors: ParseError[];
  headers: string[];
}

export interface ParseError {
  row: number;
  message: string;
  data?: string;
}

// Temporary hash generation for local duplicate detection within CSV
// Real hashes will be generated by backend service
function createTemporaryHash(date: string, partner: string, amount: number): string {
  // Simple unique identifier for local duplicate detection
  return `temp_${date}_${partner}_${amount}`;
}

// Parse CSV content with smart field detection
export function parseCSV(content: string): ParseResult {
  const lines = content.split('\n').filter(line => line.trim());
  
  if (lines.length < 2) {
    return {
      transactions: [],
      errors: [{ row: 0, message: 'CSV must have header and at least one data row' }],
      headers: []
    };
  }

  const headerLine = lines[0];
  const headers = parseCSVLine(headerLine);
  const fieldMapping = detectFieldMapping(headers);
  
  const transactions: ParsedTransaction[] = [];
  const errors: ParseError[] = [];
  const hashSet = new Set<string>();

  for (let i = 1; i < lines.length; i++) {
    try {
      const values = parseCSVLine(lines[i]);
      if (values.length === 0) continue;

      const transaction = mapToTransaction(values, fieldMapping, i + 1);
      if (transaction) {
        // Check for duplicates
        const existingHash = hashSet.has(transaction.hash);
        if (existingHash) {
          transaction.isDuplicate = true;
          transaction.selected = false;
          transaction.duplicateReason = 'Identical transaction already exists';
        } else {
          hashSet.add(transaction.hash);
        }

        transactions.push(transaction);
      }
    } catch (error) {
      errors.push({
        row: i + 1,
        message: error instanceof Error ? error.message : 'Unknown parsing error',
        data: lines[i]
      });
    }
  }

  return { transactions, errors, headers };
}

// Parse a single CSV line handling quoted fields properly
function parseCSVLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  let i = 0;

  while (i < line.length) {
    const char = line[i];
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote
        current += '"';
        i += 2;
      } else {
        // Toggle quote state
        inQuotes = !inQuotes;
        i++;
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current.trim());
      current = '';
      i++;
    } else {
      current += char;
      i++;
    }
  }
  
  result.push(current.trim());
  return result;
}

// Smart field detection for N26 and other formats
function detectFieldMapping(headers: string[]): Record<string, number> {
  const mapping: Record<string, number> = {};
  
  const fieldPatterns = {
    bookingDate: /booking\s*date|fecha\s*reserva|date|fecha/i,
    valueDate: /value\s*date|fecha\s*valor/i,
    partnerName: /partner\s*name|nombre\s*socio|beneficiario|partner|merchant/i,
    partnerIban: /partner\s*iban|iban\s*socio|iban/i,
    type: /type|tipo|transaction\s*type/i,
    paymentReference: /payment\s*reference|referencia\s*pago|concepto|description|descripci[oÃ³]n/i,
    accountName: /account\s*name|nombre\s*cuenta|account/i,
    amountEur: /amount.*eur|importe.*eur|cantidad|amount|importe/i,
    originalAmount: /original\s*amount|importe\s*original/i,
    originalCurrency: /original\s*currency|moneda\s*original/i,
    exchangeRate: /exchange\s*rate|tipo\s*cambio/i
  };

  headers.forEach((header, index) => {
    Object.entries(fieldPatterns).forEach(([field, pattern]) => {
      if (pattern.test(header) && !mapping[field]) {
        mapping[field] = index;
      }
    });
  });

  return mapping;
}

// Map CSV values to transaction object
function mapToTransaction(values: string[], mapping: Record<string, number>, rowNumber: number): ParsedTransaction | null {
  try {
    const bookingDate = parseDate(values[mapping.bookingDate] || '');
    const valueDate = parseDate(values[mapping.valueDate] || '');
    const amountStr = values[mapping.amountEur] || '0';
    const amount = parseAmount(amountStr);
    const partner = cleanString(values[mapping.partnerName] || '');
    const description = cleanString(values[mapping.paymentReference] || '');

    if (!bookingDate || isNaN(amount) || !partner) {
      throw new Error(`Missing required fields (row ${rowNumber})`);
    }

    const dateStr = bookingDate.toISOString().split('T')[0];
    // Hash will be generated by backend, use temporary one for now
    const hash = createTemporaryHash(dateStr, partner, amount);

    return {
      id: `temp-${rowNumber}-${Date.now()}`,
      hash,
      date: dateStr,
      valueDate: valueDate?.toISOString().split('T')[0],
      partner,
      iban: cleanString(values[mapping.partnerIban] || ''),
      type: cleanString(values[mapping.type] || ''),
      description,
      account: cleanString(values[mapping.accountName] || ''),
      amount,
      originalAmount: mapping.originalAmount ? parseAmount(values[mapping.originalAmount]) : undefined,
      originalCurrency: cleanString(values[mapping.originalCurrency] || ''),
      exchangeRate: mapping.exchangeRate ? parseFloat(values[mapping.exchangeRate]) : undefined,
      selected: true,
      isDuplicate: false
    };
  } catch (error) {
    throw new Error(`Error processing row ${rowNumber}: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// Parse date with multiple format support
function parseDate(dateStr: string): Date | null {
  if (!dateStr) return null;
  
  const formats = [
    /^(\d{4})-(\d{2})-(\d{2})$/, // YYYY-MM-DD
    /^(\d{2})\/(\d{2})\/(\d{4})$/, // DD/MM/YYYY
    /^(\d{2})-(\d{2})-(\d{4})$/, // DD-MM-YYYY
  ];

  for (const format of formats) {
    const match = dateStr.match(format);
    if (match) {
      if (format === formats[0]) {
        // YYYY-MM-DD
        return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
      } else {
        // DD/MM/YYYY or DD-MM-YYYY
        return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));
      }
    }
  }

  // Try direct parsing as fallback
  const parsed = new Date(dateStr);
  return isNaN(parsed.getTime()) ? null : parsed;
}

// Parse amount with proper decimal handling
function parseAmount(amountStr: string): number {
  if (!amountStr) return 0;
  
  // Remove any non-numeric characters except . , - and +
  const cleaned = amountStr.replace(/[^\d.,+\-]/g, '');
  
  // Handle different decimal separators
  const normalized = cleaned.replace(/,/g, '.');
  
  const parsed = parseFloat(normalized);
  return isNaN(parsed) ? 0 : parsed;
}

// Clean string values
function cleanString(str: string): string {
  return str.replace(/^"|"$/g, '').trim();
}
